This file outlines issues found with the v12.0_beta AIX compiler

o Python 2.5 and boost 1.45
         Application OK but bjam problems running test automatically
         cd $BOOST_ROOT/libs/python/example
         bjam --toolset=vacpp test -d2  
         
         running test example manually are ok
          
  DEBUG: all test pass
  RELEASE: all test pass, *APART* from ACore/test/TestExceptionSafety
         It should be noted that RepeatAttr.hpp and ClientToServerRequest.hpp
         serealisation  was changed to *REMOVE* explicit type registration.
         Otherwise Node persistence checks failed, since Repeat attributes
         were not being persisted.
   
         This requires FIX 392176 (boost serialisation defect) from IBM.

p Python 2.54 and boost 1.47
  debug  : <TODO>
  release: <TODO>

o Python 2.7 and boost 1.47
  debug  : PASS
  release: <TODO>
 
o Python 2.7, and boost 1.47
  debug  : PASS
  release: <TODO>
 
 ====================================================================================


class RepeatAttr.hpp

private:
   RepeatBase* repeatType_;

   friend class boost::serialization::access;
   template<class Archive>
   void serialize(Archive & ar, const unsigned int /*version*/) {

      // This seems to fix, bug with release version of v11.1
      // Serialisation via base pointer is broken with release mode of v11.1 compiler and requires this hack.
      // i.e explicit type registration.
//#if defined(_AIX) && !defined(DEBUG)
//       ar.register_type(static_cast<RepeatDate *>(NULL));
//       ar.register_type(static_cast<RepeatInteger *>(NULL));
//       ar.register_type(static_cast<RepeatEnumerated *>(NULL));
//       ar.register_type(static_cast<RepeatString *>(NULL));
//       ar.register_type(static_cast<RepeatDay *>(NULL));
//#endif
      ar & repeatType_;
   }
};

BOOST_CLASS_EXPORT_KEY(RepeatDate)
BOOST_CLASS_EXPORT_KEY(RepeatInteger)
BOOST_CLASS_EXPORT_KEY(RepeatEnumerated)
BOOST_CLASS_EXPORT_KEY(RepeatString)
BOOST_CLASS_EXPORT_KEY(RepeatDay)

#endif



ClientToServerRequest.hpp
===============================================================================

#ifndef CLIENT_TO_SERVER_REQUEST_HPP_
#define CLIENT_TO_SERVER_REQUEST_HPP_
/////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
// Name        :
// Author      : Avi
// Revision    : $Revision: #10 $
//
// Copyright 2009-2016 ECMWF.
// This software is licensed under the terms of the Apache Licence version 2.0
// which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
// In applying this licence, ECMWF does not waive the privileges and immunities
// granted to it by virtue of its status as an intergovernmental organisation
// nor does it submit to any jurisdiction.
/////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8

#include <boost/noncopyable.hpp>
#include "ClientToServerCmd.hpp"

// Base class for client to server requesting.
// This class is used in the IPC messaging from  client to server.
class ClientToServerRequest : private boost::noncopyable {
public:

   ClientToServerRequest() {}
   ClientToServerRequest(const Cmd_ptr& cmd) : cmd_(cmd) { cmd_->setup_user_authentification();}
   ~ClientToServerRequest() {}

   void set_cmd(const Cmd_ptr& cmd) { cmd_ = cmd; cmd_->setup_user_authentification(); }
   Cmd_ptr get_cmd() const { return cmd_;}

   /// This is called in the server only, to handle the quest.
   STC_Cmd_ptr handleRequest(AbstractServer*) const;

   std::ostream& print(std::ostream& os) const;

   bool getRequest()  const { return (cmd_.get()) ? cmd_->get_cmd()  : false; }
   bool terminateRequest() const { return (cmd_.get()) ? cmd_->terminate_cmd() : false;  }
   bool groupRequest() const { return (cmd_.get()) ? cmd_->group_cmd() : false;  }

   /// Used by boost test, to verify persistence
   bool operator==(const ClientToServerRequest& rhs) const;

private:
   Cmd_ptr cmd_;
   friend class boost::serialization::access;
   template<class Archive>
   void serialize(Archive & ar, const unsigned int /*version*/) {

//#if defined(_AIX) && !defined(DEBUG)
//      // ** On AIX debug mode, implicit type registration via BOOST_CLASS_EXPORT works
//      // ** however in release mode, this fails, hence as a work
//      // ** around we do explicit type registration for both debug/release modes.
//      ar.register_type(static_cast<CtsCmd *>(NULL));
//      ar.register_type(static_cast<CSyncCmd *>(NULL));
//      ar.register_type(static_cast<CtsNodeCmd *>(NULL));
//      ar.register_type(static_cast<ClientHandleCmd *>(NULL));
//      ar.register_type(static_cast<PathsCmd *>(NULL));
//      ar.register_type(static_cast<CheckPtCmd *>(NULL));
//      ar.register_type(static_cast<LoadDefsCmd *>(NULL));
//      ar.register_type(static_cast<LogCmd *>(NULL));
//      ar.register_type(static_cast<LogMessageCmd *>(NULL));
//      ar.register_type(static_cast<BeginCmd *>(NULL));
//      ar.register_type(static_cast<ZombieCmd *>(NULL));
//      ar.register_type(static_cast<InitCmd *>(NULL));
//      ar.register_type(static_cast<EventCmd *>(NULL));
//      ar.register_type(static_cast<MeterCmd *>(NULL));
//      ar.register_type(static_cast<LabelCmd *>(NULL));
//      ar.register_type(static_cast<AbortCmd *>(NULL));
//      ar.register_type(static_cast<CtsWaitCmd *>(NULL));
//      ar.register_type(static_cast<CompleteCmd *>(NULL));
//      ar.register_type(static_cast<RequeueNodeCmd *>(NULL));
//      ar.register_type(static_cast<OrderNodeCmd *>(NULL));
//      ar.register_type(static_cast<RunNodeCmd *>(NULL));
//      ar.register_type(static_cast<ReplaceNodeCmd *>(NULL));
//      ar.register_type(static_cast<ForceCmd *>(NULL));
//      ar.register_type(static_cast<FreeDepCmd *>(NULL));
//      ar.register_type(static_cast<CFileCmd *>(NULL));
//      ar.register_type(static_cast<EditScriptCmd *>(NULL));
//      ar.register_type(static_cast<PlugCmd *>(NULL));
//      ar.register_type(static_cast<AlterCmd *>(NULL));
//      ar.register_type(static_cast<MoveCmd *>(NULL));
//      ar.register_type(static_cast<GroupCTSCmd *>(NULL));
//      ar.register_type(static_cast<ShowCmd *>(NULL));
//#endif

      ar & cmd_;
   }
};

std::ostream& operator<<(std::ostream& os, const ClientToServerRequest& d);

#endif
