How to pass an arbitarty number of argument and key word arguments form python to c++
=========================================================================================
This was abandoned, because it would break:
   1/ ecf.py. This used multiple inheritance over ecflow objects
      With MRO() it meant ecflow.Node.add() , will have a greater precdence than Derived class in ecf.py
      and hence break ecf.py.
   2/ Support of the following was abandoned.
       with Defs() as defs4:
        with Suite("s1"):
            with Task("t1"):
                Edit(var = "v")
                Trigger("a==1")
                Complete("a==1")
                Event(1,"event")
                Meter("meter",0,100)
                Label("label","value")
       The implementation mean that any call to the constrcutor in a with, will add to parent scope.
       However using WITH and node.add(Meter(...), would mean Meter gets added twice.
       Could have found a hacky way round.
       
       To support the addition of attributes and node, automatically. Each of the Node and attribute constructors
       needed overriding with make_constructor(). make_constructor only works with boost::shared_ptr
        	class_<Variable, boost::shared_ptr<Variable> >("Variable",NodeAttrDoc::variable_doc())
              .def("__init__",make_constructor(&create_Variable) )
       
       		static boost::shared_ptr<Variable> create_Variable(const std::string& name, const std::string& value) {
   				if ( node_ptr node = With::context()) node->add_variable(name,value);
   				return boost::make_shared<Variable>(name,value);}
   				
   		This is a lot of effort.
 
 
How add(...) above was enabled. kept for posterity, as it demonstrated how do deal with an arbitary number
of key word aruments. and demonstartion of EDIT constructor with an arbitary number of key word aruments.
  
     defs3 = Defs().add(
        Suite("s1").add(
            Task("t1").add(                   # support arbitary number of registered objects
                Variable("var","v"),
                Edit(name="VAR",fred="BBB"),  # support arbitary number of keyword arguments
                Trigger("a==1"),
                Complete("a==1"),
                Event(1,"event"),
                Meter("meter",0,100),
                Label("label","value")
            ),
        ),
  
// ===================================================================================

we use: 
   boost::python::extract<CLASS>(args[i]).check()  // check the type
   boost::python::extract<CLASS>(args[i])          // get the instance of that type
  
// ===================================================================================
ExportNode.cpp

#include <boost/python/tuple.hpp>
#include <boost/python/dict.hpp>
#include <boost/python/raw_function.hpp>

////////////////////////////////////////////////////////////////////////////////////////
// Allow Raw constructor creation, i.e allow any number keyword arguments
class Edit {
public:
   Edit() {}
   Edit(const boost::python::dict& dict) {
      BoostPythonUtil::dict_to_str_vec(dict,vec_);
      if ( node_ptr node = With::context()) {
         for(size_t i=0; i < vec_.size(); i++) node->addVariable(vec_[i]); // In With statement, and Use Edit constrcutor, NO add.
      }
   }
   const std::vector<Variable>& variables() const { return vec_;}
   std::string to_string() const { return "edit";}
   static object init(tuple args, dict kw) {
      // cout << "Edit::init args: " << len(args) << " kwargs " << len(kw) << "\n";
      if (len(args)!=1) throw std::runtime_error("Edit::Edit: only accepts key word arguments");
      tuple rest(args.slice(1,_));
      return args[0].attr("__init__")(kw); // calls  -> .def(init<dict>() -> Edit(const boost::python::dict& dict)
   }
private:
   std::vector<Variable> vec_;
};

////////////////////////////////////////////////////////////////////////////////////////
// Trigger & Complete thin wrapper over Expression, allows us to call:
//  Task("a").add(Trigger("a=1"),Complete("b=1"))
///////////////////////////////////////////////////////////////////////////////////
class Trigger {
public:
   Trigger(const std::string& expression) : expr_(expression){
      if ( node_ptr node = With::context()) {
         node->add_trigger_expr(expr_); // In With statement, and Using This constructor, i.e Not is Add
      }
   }
   Trigger(const PartExpression& pe ) : expr_(pe) {}
   Trigger() {}
   Trigger(const Trigger& rhs) : expr_(rhs.expr_) {}

   bool operator==( const Trigger& rhs) const { return expr_ == rhs.expr_;}
   bool operator!=( const Trigger& rhs) const { return !operator==(rhs);}
   std::string expression() const { return expr_.expression(); }
   void add( const PartExpression& t ) { expr_.add(t); }

   std::vector<PartExpression>::const_iterator part_begin() const { return expr_.part_begin();}
   std::vector<PartExpression>::const_iterator part_end() const   { return expr_.part_end();}

   const Expression& expr() const { return expr_;}
private:
   Expression expr_;
   Trigger& operator=(Trigger const& f); // prevent assignment
};

class Complete {
public:
   Complete(const std::string& expression) : expr_(expression){
      if ( node_ptr node = With::context()) {
         node->add_complete_expr(expr_); // In With statement, and Using This constructor, i.e Not is Add
      }
   }
   Complete(const PartExpression& pe ) : expr_(pe) {}
   Complete() {}
   Complete(const  Complete& rhs) : expr_(rhs.expr_) {}

   bool operator==( const Complete & rhs) const { return expr_ == rhs.expr_;}
   bool operator!=( const Complete & rhs) const { return !operator==(rhs);}
   std::string expression() const { return expr_.expression(); }
   void add( const PartExpression& t ) { expr_.add(t); }

   std::vector<PartExpression>::const_iterator part_begin() const { return expr_.part_begin();}
   std::vector<PartExpression>::const_iterator part_end() const   { return expr_.part_end();}

   const Expression& expr() const { return expr_;}
private:
   Expression expr_;
   Complete & operator=( Complete const& f); // prevent assignment
};

static node_ptr node_getattr(node_ptr self, std::string attr) {
   // cout << " node_getattr  self.name() : " << self->name() << "  attr " << attr << "\n";
   size_t pos = 0;
   node_ptr child = self->findImmediateChild(attr,pos);
   if (child) { return child;}
   std::stringstream ss; ss << "ExportNode::node_getattr can not find child node " << attr << " from node " << self->absNodePath();
   throw std::runtime_error(ss.str());
   return node_ptr();
}

static void node_setattr(node_ptr self, std::string name, std::string value){ self->add_variable(name,value);}


   // see: https://github.com/boostorg/python/blob/master/test/raw_ctor.cpp
   // Uses a raw constructor approach to support pass arbitrary number arguments on the python side.
   // using no_init postpones defining __init__ function until after raw_function for proper overload resolution order,
   // since later defs get higher priority.
   class_<Edit>("Edit", "Allow variable addition as keyword arguments. The values must strings or integers", no_init)
             .def("__init__", raw_function(&Edit::init,0)) // raw_constructor -> will call -> def(init<dict>() )
             .def(init<dict>())                 //
             .def("__str__",  &Edit::to_string) // __str__
             ;

   // Trigger & Complete thin wrapper over Expression, allows us to call: Task("a").add(Trigger("a=1"),Complete("b=1"))
   class_<Trigger,boost::shared_ptr<Trigger> >("Trigger",DefsDoc::expression_doc(), init<std::string>() )
   .def(init<PartExpression>())
   .def(self == self )                            // __eq__
   .def("__str__",        &Trigger::expression)   // __str__
   .def("get_expression", &Trigger::expression, "returns the complete expression as a string")
   .def("add",            &Trigger::add,"Add a part expression, the second and subsequent part expressions must have 'and/or' set")
   .add_property("parts", boost::python::range( &Trigger::part_begin, &Trigger::part_end),"Returns a list of PartExpression's" )
   ;
   class_<Complete,boost::shared_ptr<Complete> >("Complete",DefsDoc::expression_doc(), init<std::string>() )
   .def(init<PartExpression>())
   .def(self == self )                             // __eq__
   .def("__str__",        &Complete::expression)   // __str__
   .def("get_expression", &Complete::expression, "returns the complete expression as a string")
   .def("add",            &Complete::add,"Add a part expression, the second and subsequent part expressions must have 'and/or' set")
   .add_property("parts", boost::python::range( &Complete::part_begin, &Complete::part_end),"Returns a list of PartExpression's" )
   ;

	class_<Node, boost::noncopyable, node_ptr >("Node", DefsDoc::node_doc(), no_init)
   			.def("name",&Node::name, return_value_policy<copy_const_reference>() )
   			.def("add", raw_function(join,1))
   			.def("__getattr__", &node_getattr) /* Any attempt to resolve a property, method, or field name that doesn't actually exist on the object itself will be passed to __getattr__*/
            .def("__setattr__", &node_setattr) /* use to add a variable */
   			
   			.....
   			assert suite.f1.t1.name() == "t1"   // use of __getattr__
   			node.VAR = "VALUE"                  // use of __setattr__
   			


static object add(tuple args, dict kwargs) {
   cout << "JOIN==========================================================\n";
   With in_add; // Using join(..) Hence avoid adding Object, when inside a python with:

   int the_list_size = len(args);
   node_ptr self = boost::python::extract<node_ptr>(args[0]); // self
   if (!self) throw std::runtime_error("ExportNode::add() : first argument is not a node");
   for (int i = 1; i < the_list_size; ++i) {
      if (boost::python::extract<Variable>(args[i]).check())       self->addVariable(boost::python::extract<Variable>(args[i]) );
      else if (boost::python::extract<Edit>(args[i]).check()) {
         Edit edit = boost::python::extract<Edit>(args[i]);
         const std::vector<Variable>& vec = edit.variables();
         for(size_t i=0; i < vec.size(); i++) self->addVariable(vec[i]);
      }
      else if (boost::python::extract<Event>(args[i]).check())     self->addEvent(boost::python::extract<Event>(args[i]));
      else if (boost::python::extract<Meter>(args[i]).check())     self->addMeter(boost::python::extract<Meter>(args[i]));
      else if (boost::python::extract<Label>(args[i]).check())     self->addLabel(boost::python::extract<Label>(args[i]));
      else if (boost::python::extract<Limit>(args[i]).check())     self->addLimit(boost::python::extract<Limit>(args[i]));
      else if (boost::python::extract<InLimit>(args[i]).check())   self->addInLimit(boost::python::extract<InLimit>(args[i]));
      else if (boost::python::extract<DayAttr>(args[i]).check())   self->addDay(boost::python::extract<DayAttr>(args[i]));
      else if (boost::python::extract<DateAttr>(args[i]).check())  self->addDate(boost::python::extract<DateAttr>(args[i]));
      else if (boost::python::extract<TodayAttr>(args[i]).check()) self->addToday(boost::python::extract<TodayAttr>(args[i]));
      else if (boost::python::extract<TimeAttr>(args[i]).check())  self->addTime(boost::python::extract<TimeAttr>(args[i]));
      else if (boost::python::extract<CronAttr>(args[i]).check())  self->addCron(boost::python::extract<CronAttr>(args[i]));
      else if (boost::python::extract<LateAttr>(args[i]).check())  self->addLate(boost::python::extract<LateAttr>(args[i]));
      else if (boost::python::extract<ZombieAttr>(args[i]).check())self->addZombie(boost::python::extract<ZombieAttr>(args[i]));
      else if (boost::python::extract<RepeatDate>(args[i]).check())self->addRepeat(Repeat(boost::python::extract<RepeatDate>(args[i])  ));
      else if (boost::python::extract<RepeatInteger>(args[i]).check())self->addRepeat(Repeat(boost::python::extract<RepeatInteger>(args[i])  ));
      else if (boost::python::extract<RepeatEnumerated>(args[i]).check())self->addRepeat(Repeat(boost::python::extract<RepeatEnumerated>(args[i])  ));
      else if (boost::python::extract<RepeatString>(args[i]).check())self->addRepeat(Repeat(boost::python::extract<RepeatString>(args[i])  ));
      else if (boost::python::extract<RepeatDay>(args[i]).check())self->addRepeat(Repeat(boost::python::extract<RepeatDay>(args[i])  ));
      else if (boost::python::extract<AutoCancelAttr>(args[i]).check())self->addAutoCancel(boost::python::extract<AutoCancelAttr>(args[i]));
      else if (boost::python::extract<VerifyAttr>(args[i]).check())self->addVerify(boost::python::extract<VerifyAttr>(args[i]));
      else if (boost::python::extract<Trigger>(args[i]).check()){ Trigger t = boost::python::extract<Trigger>(args[i]); self->add_trigger_expr(t.expr());}
      else if (boost::python::extract<Complete>(args[i]).check()){Complete t = boost::python::extract<Complete>(args[i]);self->add_complete_expr(t.expr());}
      else if (boost::python::extract<ClockAttr>(args[i]).check()) {
         if (!self->isSuite() ) throw std::runtime_error("ExportNode::add() : Can only add a clock to a suite");
         self->isSuite()->addClock( boost::python::extract<ClockAttr>(args[i]));
      }
      else if (boost::python::extract<node_ptr>(args[i]).check()) {
         NodeContainer* nc = self->isNodeContainer();
         if (!nc) throw std::runtime_error("ExportNode::add() : Can only add a child to Suite or Family");
         node_ptr child = boost::python::extract<node_ptr>(args[i]);
         nc->addChild(child);
      }
      else if (boost::python::extract<dict>(args[i]).check()){dict d = boost::python::extract<dict>(args[i]); add_variable_dict(self,d);}
      else throw std::runtime_error("ExportNode::add : Unknown type ");
   }

   // key word arguments are use for adding variable only
   boost::python::list keys = kwargs.keys();
   const int no_of_keys = len(keys);
   for(int i = 0; i < no_of_keys; ++i) {
      boost::python::object curArg = keys[i];
      if (curArg) {
         std::string first = boost::python::extract<std::string>(keys[i]);
         std::string second = boost::python::extract<std::string>(kwargs[keys[i]]);
         self->add_variable(first,second);
      }
   }
   return object(self); // return node_ptr as python object, relies class_<Node>... for type registration
}

// ==================================================================

class_<Defs,defs_ptr >( "Defs", DefsDoc::add_definition_doc() ,init<>("Create a empty Defs"))
   .def("add", raw_function(add,1))

static object add(tuple args, dict kwargs) {
   With in_add; // avoid adding with in add

   int the_list_size = len(args);
   defs_ptr self = boost::python::extract<defs_ptr>(args[0]); // self
   if (!self) throw std::runtime_error("ExportDefs::add() : first argument is not a defs");

   for (int i = 1; i < the_list_size; ++i) {
      if (boost::python::extract<Variable>(args[i]).check()) {
         Variable var = boost::python::extract<Variable>(args[i]);
         self->set_server().add_or_update_user_variables(var.name(),var.theValue());
      }
      else if (boost::python::extract<dict>(args[i]).check())      add_variable_dict(self,boost::python::extract<dict>(args[i]) );
      else if (boost::python::extract<suite_ptr>(args[i]).check()) self->addSuite(boost::python::extract<suite_ptr>(args[i])) ;
      else throw std::runtime_error("ExportDefs::add : Unknown type");
   }

   boost::python::list keys =  kwargs.keys();
   const int no_of_keys = len(keys);
   for(int i = 0; i < no_of_keys; ++i) {
      boost::python::object curArg = keys[i];
      if (curArg) {
         std::string first = boost::python::extract<std::string>(keys[i]);
         std::string second = boost::python::extract<std::string>(kwargs[keys[i]]);
         self->set_server().add_or_update_user_variables(first,second);
      }
   }
   return object(self); // return defs as python object, relies class_<Defs>... for type registration
}


API
============================================================================

The default api is provided by the ecflow module.

However this API can be tailored to be more object oriented.

There can be two ways of using this API.
Lets assume we have specified this API in ecf.py

o The contents of ecf.py can be placed in
  __init__.py. So that whenever the user imports
  ecflow, the corresponding API is automatically available.
  
  + This is no confusion here.
  + the API will be versioned along with the extension.
  + tested
  - Hard wired, however it can still be updated by
    the user if required
  
o leave as a specific import:
  
  import ecf
  
  + Need a separate version.
  + more flexible
  - version mismatch between extension and API could arise
  - Need to test separately
  
Client- Set port specific to a user
======================================================================

import os
import socket

etc ...

defs = Defs()
defs.add(suite)
ci = ecflow.Client()
ci.set_host_port(socket.gethostname(),os.geteuid()+1500)
ci.load(defs)
ci.begin_suite(node_name)

  