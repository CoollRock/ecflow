//============================================================================
// Copyright 2014 ECMWF. 
// This software is licensed under the terms of the Apache Licence version 2.0 
// which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
// In applying this licence, ECMWF does not waive the privileges and immunities 
// granted to it by virtue of its status as an intergovernmental organisation 
// nor does it submit to any jurisdiction. 
//
//============================================================================


#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/foreach.hpp>

#include <iostream>
#include <stack>

#include <QMessageBox>
#include <QMenu>
#include <QLabel>
#include <QWidgetAction>
#include <QDebug>

#include "MenuHandler.hpp"
#include "ServerHandler.hpp"
#include "UserMessage.hpp"
#include "VNode.hpp"
#include "VNState.hpp"
#include "VSState.hpp"
#include "Str.hpp"


std::vector<Menu *> MenuHandler::menus_;


MenuHandler::MenuHandler()
{
    menus_.clear();
}


// ---------------------------------------------------------
// MenuHandler::readMenuConfigFile
// Read the given config file and store the resulting menus
// internally.
// ---------------------------------------------------------

bool MenuHandler::readMenuConfigFile(const std::string &configFile)
{
	// parse the response using the boost JSON property tree parser

	using boost::property_tree::ptree;
	ptree pt;

	try
	{
		read_json(configFile, pt);
	}
	catch (const boost::property_tree::json_parser::json_parser_error& e)
	{
        std::string errorMessage = e.what();
        UserMessage::message(UserMessage::ERROR, true, std::string("Error, unable to parse JSON menu file : " + errorMessage));
		return false;
    }



    // iterate over the top level of the tree

	for (ptree::const_iterator itTopLevel = pt.begin(); itTopLevel != pt.end(); ++itTopLevel)
    {
        // parse the menu definitions?

        if (itTopLevel->first == "menus")
        {
            UserMessage::message(UserMessage::DBG, false, std::string("Menus:"));

            ptree const &menusDef = itTopLevel->second;

            // iterate through all the menus

		    for (ptree::const_iterator itMenus = menusDef.begin(); itMenus != menusDef.end(); ++itMenus)
            {
                ptree const &menuDef = itMenus->second;

                std::string cname = menuDef.get("name", "NoName");
                UserMessage::message(UserMessage::DBG, false, std::string("  ") + cname);
                Menu *menu = new Menu(cname);

                //ptree const &menuModesDef = menuDef.get_child("modes");

		        //for (ptree::const_iterator itMenuModes = menuModesDef.begin(); itMenuModes != menuModesDef.end(); ++itMenuModes)
                //{
                //    std::cout << "   +" << itMenuModes->second.data() << std::endl;
                //}

                std::string parentMenuName = menuDef.get("parent", "None");

                if (parentMenuName != "None")
                {
                }

                addMenu(menu);  // add to our list of available menus

            }
        }

        // parse the menu items?

        else if (itTopLevel->first == "menu_items")
        {
            UserMessage::message(UserMessage::DBG, false, std::string("Menu items:"));

            ptree const &itemsDef = itTopLevel->second;

            // iterate through all the items

            for (ptree::const_iterator itItems = itemsDef.begin(); itItems != itemsDef.end(); ++itItems)
            {
                ptree const &ItemDef = itItems->second;

                std::string name     = ItemDef.get("name",    "NoName");
                std::string menuName = ItemDef.get("menu",    "NoMenu");
                std::string command  = ItemDef.get("command", "NoCommand");
                std::string type     = ItemDef.get("type",    "Command");
                //std::cout << "  " << name << " :" << menuName << std::endl;

                MenuItem *item = new MenuItem(name);
                item->setCommand(command);

                if (type == "Submenu")
                    item->setAsSubMenu();

                addItemToMenu(item, menuName);
                //std::cout << "   added" << std::endl;

                // tell the ServerHandler how to translate from the item name to an actual command
                ServerHandler::addServerCommand(name, command);


                // parse the valid node types/states for this menu item

                if( ItemDef.count("valid_types") > 0 )  // does this node exist on the tree?
                {
                    ptree ptValidTypes = ItemDef.get_child("valid_types");
		            for (ptree::const_iterator itTypes = ptValidTypes.begin(); itTypes != ptValidTypes.end(); ++itTypes)
                    {
                        std::string type(itTypes->second.data());
                        item->addValidType(type);
                    }
                }
                else
                {
                    item->addValidType("all");
                }


                if( ItemDef.count("valid_states") > 0 )  // does this node exist on the tree?
                {
                    ptree ptValidStates = ItemDef.get_child("valid_states");
		            for (ptree::const_iterator itStates = ptValidStates.begin(); itStates != ptValidStates.end(); ++itStates)
                    {
                        std::string state(itStates->second.data());
                        item->addValidState(state);
                    }
                }
                else
                {
                    item->addValidState("all");
                }
            }
        }
    }


    //ptree ptMenus = pt.get_child("menus");




	//for (ptree::const_iterator itTopLevel = pt.begin(); itTopLevel != pt.end(); ++itTopLevel)
    //{
    //    if (itTopLevel->first == "menus")

    //}




    return true;
}



Menu *MenuHandler::findMenu(const std::string &name)
{
    for (std::vector<Menu *>::iterator itMenus = menus_.begin(); itMenus != menus_.end(); ++itMenus)
    {
        if ((*itMenus)->name() == name)
        {
            return (*itMenus);
        }
    }

    return NULL; // if we got to here, then the menu was not found
}


MenuItem* MenuHandler::newItem(const std::string &name)
{
}

bool MenuHandler::addItemToMenu(MenuItem *item, const std::string &menuName)
{
    Menu *menu = findMenu(menuName);
    // items_.push_back(item); // add to our global list of menu items
    
    if (menu)
    {
        menu->addItem(item);
    }
    else
    {
        UserMessage::message(UserMessage::ERROR, false, std::string("Could not find menu called " + 
                             menuName + " to add item " + item->name() + " to."));
        return false;
    }
}


QAction *MenuHandler::invokeMenu(const std::string &menuName, std::vector<VInfo_ptr> nodes, QPoint pos, QWidget *parent)
{
    QAction *selectedAction = NULL;
    Menu *menu = findMenu(menuName);

    if (menu)
    {
        QMenu *qMenu = menu->generateMenu(nodes, parent);

        selectedAction = qMenu->exec(pos);

        delete qMenu;
    }

    return selectedAction;
}



// ----------------------
// Node condition classes
// ----------------------


class BaseNodeCondition
{
public:
    BaseNodeCondition() {};
    virtual ~BaseNodeCondition() {};

    virtual bool execute(VInfo_ptr nodeInfo) = 0;
    virtual int  numOperands() {return 0;};
};

// -----------------------------------------------------------------

class AndNodeCondition : public BaseNodeCondition
{
public:
    AndNodeCondition(BaseNodeCondition *left=NULL, BaseNodeCondition *right=NULL) {left_ = left; right_ = right;};
    ~AndNodeCondition() {};

    bool execute(VInfo_ptr nodeInfo) {return left_->execute(nodeInfo) && right_->execute(nodeInfo);};
    int  numOperands() {return 2;};

private:
    BaseNodeCondition *left_;
    BaseNodeCondition *right_;
};

// -----------------------------------------------------------------

class OrNodeCondition : public BaseNodeCondition
{
public:
    OrNodeCondition(BaseNodeCondition *left=NULL, BaseNodeCondition *right=NULL) {left_ = left; right_ = right;};
    ~OrNodeCondition() {};

    bool execute(VInfo_ptr nodeInfo) {return left_->execute(nodeInfo) || right_->execute(nodeInfo);};
    int  numOperands() {return 2;};

private:
    BaseNodeCondition *left_;
    BaseNodeCondition *right_;
};

// -----------------------------------------------------------------

class NotNodeCondition : public BaseNodeCondition
{
public:
    NotNodeCondition(BaseNodeCondition *child=NULL) {child_ = child;};
    ~NotNodeCondition() {};

    bool execute(VInfo_ptr nodeInfo) {return !(child_->execute(nodeInfo));};
    int  numOperands() {return 1;};

private:
    BaseNodeCondition *child_;
};

// -----------------------------------------------------------------

class TypeNodeCondition : public BaseNodeCondition
{
public:
    TypeNodeCondition(MenuItem::NodeType type) {type_ = type;};
    ~TypeNodeCondition() {};

    bool execute(VInfo_ptr nodeInfo)
    {
        if (type_ == MenuItem::SERVER && nodeInfo->isServer())
            return true;

        if(nodeInfo->isNode())
        {
            Node *node = nodeInfo->node()->node();

            if (type_ == MenuItem::SUITE && node->isSuite())
                return true;

            if (type_ == MenuItem::TASK && node->isTask())
                return true;

            if (type_ == MenuItem::ALIAS && node->isAlias())
                return true;

            if (type_ == MenuItem::FAMILY && node->isFamily())
                return true;
        }

        return false;
    };

private:
    MenuItem::NodeType type_;
};


// -----------------------------------------------------------------

class StateNodeCondition : public BaseNodeCondition
{
public:
    StateNodeCondition(QString stateName) {stateName_ = stateName;};
    ~StateNodeCondition() {};

    bool execute(VInfo_ptr nodeInfo)
    {
        if (nodeInfo->isServer())
        {
            return (VSState::toName(nodeInfo->server()) == stateName_);
        }

        if(nodeInfo->isNode())
        {
            Node *node = nodeInfo->node()->node();

            return (VNState::toName(node) == stateName_);
        }

        return false;
    };

private:
    QString stateName_;
};

// -----------------------------------------------------------------


///////////////////////////////////////////////////////////

// -------------------------
// Expression parser classes
// -------------------------

class NodeExpressionParser
{
public:
    NodeExpressionParser()  {};
    ~NodeExpressionParser() {};


    static BaseNodeCondition *parseWholeExpression(std::string);
    static BaseNodeCondition *parseExpression(std::vector<std::string> &tokens);

};


BaseNodeCondition *NodeExpressionParser::parseWholeExpression(std::string expr)
{
    std::vector<std::string> tokens;
    std::string delimiters(" ");

    // XXXX to do: convert to lowercase(?)

    ecf::Str::split(expr, tokens, delimiters);

    return parseExpression(tokens);
}


BaseNodeCondition *NodeExpressionParser::parseExpression(std::vector<std::string> &tokens)
{
    BaseNodeCondition *result = NULL;

    std::stack<BaseNodeCondition *> funcStack;
    std::stack<BaseNodeCondition *> operandStack;



    for(std::vector<std::string>::const_iterator i = tokens.begin(); i != tokens.end(); i++)
    {
        bool tokenOk = true;

        // node types  XXXXXXXXXXXXX
        if (*i == "task")
        {
            TypeNodeCondition *typeCond = new TypeNodeCondition(MenuItem::TASK);
            operandStack.push(typeCond);
            result = typeCond;
        }


        // node states
        else if (DState::isValid(*i))
        {
            StateNodeCondition *stateCond = new StateNodeCondition(QString::fromStdString(*i));
            operandStack.push(stateCond);
            result = stateCond;
        }


        // logical operators
        else if (*i == "and")
        {
            AndNodeCondition *andCond = new AndNodeCondition();
            funcStack.push(andCond);
            result = andCond;
        }
        
        else
        {
            tokenOk = false;
        }

        if (tokenOk)
        {
            // if there are enough operands on the stack for the last
            // function, pop them off and create a small tree for that function
            if (!funcStack.empty())
            {
                if(operandStack.size() == funcStack.top()->numOperands())
                {
                }
            }


        }


    }

    return result;
}


// --------------------
// Menu class functions
// --------------------



Menu::Menu(const std::string &name) : name_(name)
{
}


Menu::~Menu()
{
    for (std::vector<MenuItem*>::iterator itItems = items_.begin(); itItems != items_.end(); ++itItems)
    {
        if (*itItems)
            delete (*itItems);
    }
}


QMenu *Menu::generateMenu(std::vector<VInfo_ptr> nodes, QWidget *parent)
{
    bool showIcompatibleItems = true;
    QMenu *qmenu=new QMenu(parent);	
    qmenu->setTitle(QString::fromStdString(name()));

    //qmenu->setWindowFlags(Qt::Tool);
    //qmenu->setWindowTitle("my title");


    // add an inactive action(!) to the top of the menu in order to show which
    // node has been selected

    if (nodes.size() == 1)
    {
        /*
        QLabel *nodeLabel = new QLabel(QString::fromStdString((*nodes[0]).node()->name()));
        nodeLabel->setStyleSheet("QLabel { background-color : red; color : blue; }");
        nodeLabel->setAlignment(Qt::AlignHCenter);
        
        nodeLabel->setObjectName("nodeLabel");
        QWidgetAction *action = new QWidgetAction(0);
        action->setDefaultWidget(nodeLabel);
        */

        QAction *action = new QAction(0);
        action->setText(QString::fromStdString((*nodes[0]).name()));
        qmenu->addAction(action);
        action->setParent(parent);
        action->setEnabled(false);
        QFont menuTitleFont;
        menuTitleFont.setBold(true);
        menuTitleFont.setItalic(true);
        action->setFont(menuTitleFont);
    }

    //TypeNodeCondition  typeCondFamily   (MenuItem::FAMILY);
    //TypeNodeCondition  typeCondTask     (MenuItem::TASK);
    //StateNodeCondition stateCondUnknown ("unknown");
    //OrNodeCondition    orCond           (&typeCondFamily, &typeCondTask);
    //AndNodeCondition   andCond          (&orCond, &stateCondUnknown);

    std::string condString("task");
    BaseNodeCondition *nodeCond = NodeExpressionParser::parseWholeExpression(condString);

    if (nodeCond == NULL)
    {
        UserMessage::message(UserMessage::ERROR, true, std::string("Error, unable to parse condition: " + condString));
    }



    for (std::vector<MenuItem*>::iterator itItems = items_.begin(); itItems != items_.end(); ++itItems)
    {
        //  is this item valid for the current selection?

        bool compatible = true;

        for (std::vector<VInfo_ptr>::iterator itNodes = nodes.begin(); itNodes != nodes.end(); ++itNodes)
        {
            //compatible = compatible && (*itItems)->compatibleWithNode(*itNodes);
            compatible = compatible && (nodeCond != NULL && nodeCond->execute(*itNodes));
        }

        if (showIcompatibleItems)
        {
            if ((*itItems)->isSubMenu())
            {
                //QMenu *subMenu = qmenu->addMenu(QString::fromStdString((*itItems)->name()));
                Menu *menu = MenuHandler::findMenu((*itItems)->name());
                if (menu)
                {
                    QMenu *subMenu = menu->generateMenu(nodes, 0);
                    qmenu->addMenu(subMenu);
                }
            }
            else if  ((*itItems)->isDivider())
            {
                qmenu->addSeparator();
            }
            else
            {
                QAction *action = (*itItems)->action();
                qmenu->addAction(action);
                action->setParent(parent);
                action->setEnabled(compatible);
            }
        }
        else
        {
            if (compatible)
            {
                QAction *action = (*itItems)->action();
                action->setParent(parent);
                qmenu->addAction(action);
            }
        }
    }


    return qmenu;
}


// ------------------------
// MenuItem class functions
// ------------------------

MenuItem::MenuItem(const std::string &name) : name_(name), action_(0), isSubMenu_(false), isDivider_(false)
{
    if (name == "-")
    {
        isDivider_ = true;
    }
    else
    {
        action_ = new QAction(0);
        action_->setText(QString(name.c_str()));
    }
}


MenuItem::~MenuItem()
{
    if (action_)
        delete action_;
}

void MenuItem::setCommand(const std::string &command)
{
    command_ = command;

    if (action_)
        action_->setStatusTip(QString(command.c_str()));  // so we see the command in the status bar
};

// adds an entry to the list of valid node types for this menu item
void MenuItem::addValidType(std::string type)
{
    static NodeType all[] = {TASK, FAMILY, SUITE, SERVER, ALIAS};

    if     (type == "server")
        validNodeTypes_.push_back(SERVER);
    else if(type == "suite")
        validNodeTypes_.push_back(SUITE);
    else if(type == "task")
        validNodeTypes_.push_back(TASK);
    else if(type == "family")
        validNodeTypes_.push_back(FAMILY);
    else if(type == "alias")
        validNodeTypes_.push_back(ALIAS);
    else if(type == "all")
        validNodeTypes_.insert(validNodeTypes_.begin(), all, all+5);
}


// adds an entry to the list of valid node types for this menu item
void MenuItem::addValidState(std::string state)
{
    DState::State dstate;

    if (DState::isValid(state))
    {
        dstate = DState::toState(state);
        validNodeStates_.push_back(dstate);
    }
    else if (state == "all")
    {
        // add the list of all states
        std::vector<DState::State> allDstates = DState::states();
        validNodeStates_.insert(validNodeStates_.end(), allDstates.begin(), allDstates.end());
    }
    else
    {
        UserMessage::message(UserMessage::ERROR, false, std::string("Bad node state in menu file: " + state));
    }
}


bool MenuItem::isNodeTypeValidForMenuItem(NodeType type)
{
    if(std::find(validNodeTypes_.begin(), validNodeTypes_.end(), type) == validNodeTypes_.end())
        return false;
    else
        return true;
}


bool MenuItem::compatibleWithNode(VInfo_ptr nodeInfo)
{
    // check each node type and return false if we don't match

    if(nodeInfo->isServer())
        if(std::find(validNodeTypes_.begin(), validNodeTypes_.end(), SERVER) == validNodeTypes_.end())
            return false;

    if(nodeInfo->isNode())
    {
        Node *node = nodeInfo->node()->node();

        if(node->isSuite())
            if (!isNodeTypeValidForMenuItem(SUITE))
                return false;

        if(node->isTask())
            if (!isNodeTypeValidForMenuItem(TASK))
                return false;

        if(node->isAlias())
            if (!isNodeTypeValidForMenuItem(ALIAS))
                return false;

        if(node->isFamily())
            if (!isNodeTypeValidForMenuItem(FAMILY))
                return false;
    }

    return true;
}
